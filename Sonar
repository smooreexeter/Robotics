#pragma config(Sensor, dgtl1,  dOut,           sensorDigitalOut)
#pragma config(Motor,  port1,           mot,           tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

struct stackElem{
	int val;
} stackElem;

struct Stack{
	stackElem elements[16];
	int size;
}Stack;

void wait(int var){
	wait1Msec(var);
}




bool push(Stack stack, int val){
	if(stack.size == 16){
		return false;
	}
	
	stack.elements[stack.size++].val = val;
	return true;
}

int pop(Stack stack){
	if(stack.size == 0){
		return -1;
	}
	
	return stack.elements[--stack.size].val;
}

void  createBinary(Stack st, int val){
	
	int pushVal;
	
	while(val > 0){
		pushVal = val%2;
		push(st, pushVal);
		val = (val - pushVal) / 2;
	}
	
}

void stackOut(Stack st){
	
		while(st.size > 0){
		if(pop(st) == 1){
			SensorValue[dOut] = 0;
			wait(500);
			SensorValue[dOut] = 1;
		}else{
			SensorValue[dOut] = 0;
			wait(250);
			SensorValue[dOut] = 1;
			wait(250);
		}
		wait(500);	
	}
}


void navMaze(){

}

void com(){
	Stack st[numTurns];
	
	for(int i = 0; i < numTurns; i++){
		createBinary(st[i], abs(dir[i]));
	}
	
	SensorValue[dOut] = 1;
	wait(1000);
	SensorValue[dout] = 0;
	wait(500);
	
	int temp;
	int numTurns = 10;
	int dir[numTurns];
	
	for(int i = 0; i < numTurns; i++){
		for(int j = 0; j < st.size; j++){
			temp = pop(st);
			if(temp = 0){
				wait(10);
			}else{
				SensorValue[dOut] = 1;
				wait(10);
				SensorValue[dOut] = 0;
			}
			wait(5);
		}
		if(sgn((float) dir[i]) == 1){
			SensorValue[dOut] = 1;
			wait(100);
			SensorValue[dOut] = 0;
			wait(250);
		}else{
			SensorValue[dOut] = 1;
			wait(200);
			SensorValue[dOut] = 0;
			wait(250);
		}
	}
}
		


task main(){
	Stack st[5];

	
	createBinary(st[0], 8000);
	createBinary(st[1], 5000);
	
	stackOut(st[0]);
	wait(5000);
	stackOut(st[1]);
	

}
