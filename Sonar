#pragma config(Sensor, dgtl1,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  bump,           sensorDigitalIn)
#pragma config(Sensor, dgtl6,  sonar,          sensorSONAR_cm)
#pragma config(Motor,  port2,           rightMotor,    tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port3,           leftMotor,     tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void wait(int val){
	wait1Msec(val);
}

void rampUp(int length, int targetSpeed, float fac, int dir){

	if(length == 0){
		length  = 30;
	}
	int time = length;
	int speed = 20;
	int interval = 5;

	while(speed < targetSpeed){
		motor[leftMotor] = speed * sgn(dir);
		motor[rightMotor] = speed * fac * sgn(dir);

		speed += interval;
		wait(time);
	}
	speed = targetSpeed;

}

void forwardForDistance(int dist){

	float a = 5.7;
	float k = .79;
	rampUp(0, 65, k, 1);
	while(SensorValue[rightEncoder] < dist*a){
		motor[leftMotor] = 65;
		motor[rightMotor] = 65 * k;
	}

	SensorValue[rightEncoder] = 0;

}

void reverseForDistance(int dist){

	float a = -5.8;
	float k = 1.1;
	rampUp(0, 65, k, -1);
	while(SensorValue[rightEncoder] > dist*a){
		motor[leftMotor] = -65;
		motor[rightMotor] = -65 * k;
	}

	SensorValue[rightEncoder] = 0;

}

void turn(int dir, int num){
	//left turn  = -1, right turn = 1
	for(int i  = 0; i < num; i++){

		if(dir < 0){

			int k = 250; //too big

			while(SensorValue[rightEncoder] < k){
				motor[leftMotor] = -80;
				motor[rightMotor] = 80;
			}
			motor[leftMotor] = 0;
			motor[rightMotor] = 0;

		}else{

			int k = 250;

			while(SensorValue[rightEncoder] > -k){
				motor[leftMotor] = 80;
				motor[rightMotor] = -80;
			}
			motor[leftMotor] = 0;
			motor[rightMotor] = 0;
		}

		SensorValue[rightEncoder] = 0;
		wait(1000);

	}

}

void rightTurn90()
{
	int k = 170;

	while(SensorValue[rightEncoder] > -k)
	{
		motor[rightMotor] = -80;
		motor[leftMotor] = 80;
	}
	motor[rightMotor] =0;
	motor[leftMotor] = 0;

	SensorValue[rightEncoder] = 0;
	wait(1000);
}

void rightTurn180()
{
	int k = 328;

	while(SensorValue[rightEncoder] > -k)
	{
		motor[rightMotor] = -80;
		motor[leftMotor] = 80;
	}
	motor[rightMotor] =0;
	motor[leftMotor] = 0;

	SensorValue[rightEncoder] = 0;
	wait(1000);
}

void leftTurn90()
{
	int k = 193;

	while(SensorValue[rightEncoder] < k)
	{
		motor[rightMotor] = 80;
		motor[leftMotor] = -80;
	}
	motor[rightMotor] =0;
	motor[leftMotor] = 0;

	SensorValue[rightEncoder] = 0;
	wait(1000);
}

void leftTurn180()
{
	SensorValue[rightEncoder] = 0;
	int k = 330;

	while(SensorValue[rightEncoder] < k)
	{
		motor[rightMotor] = 80;
		motor[leftMotor] = -80;
	}
	motor[rightMotor] =0;
	motor[leftMotor] = 0;

	SensorValue[rightEncoder] = 0;
	wait(1000);
}

void goStraight(int dist){

	float a = 5.7;
	float k = 0.79;
	//rampUp(0, 65, k, 1);
	int R = 40;
	//float g = 1;
	int RE = 0;
	int LE = 0;

	//SensorValue[leftEncoder] = 10;
	//SensorValue[rightEncoder] = 10;

	while(SensorValue[rightEncoder] < dist * a  && SensorValue[leftEncoder] < dist * a){

		motor[leftMotor] = 40;
		motor[rightMotor] = R;
		LE = SensorValue[leftEncoder];
		RE = SensorValue[rightEncoder];
		//if(RE > 1){
	  	R = R * (LE + 1) / (RE + 1);
		//} else{
		//	R = 40;
		//}
		wait(500);

	}

	//SensorValue[leftEncoder] = 0;
	//SensorValue[rightEncoder] = 0;
	motor[leftMotor] = 0;
	motor[rightMotor] = 0;

}

int goStraighter(int dist, int encoder)
{
	float a = 4.6;
	int ret;
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;
	if(encoder > -1){
		dist = encoder/a;
	}
 while(SensorValue[rightencoder] < dist * a && SensorValue[leftencoder] < dist * a)
	{
		while(SensorValue[rightencoder] == SensorValue[leftencoder] )
		{
			motor[rightMotor] = 40 * 0.79;
			motor[leftMotor] = 40;
			wait(10);
		}
		while(SensorValue[rightencoder] > SensorValue[leftencoder] )
		{
			motor[leftMotor] = 40;
			motor[rightMotor] = 30;
			wait(10);
		}
		while(SensorValue[rightencoder] < SensorValue[leftencoder] )
		{
			motor[leftMotor] = 30;
			motor[rightMotor] = 40;
			wait(10);
		}
	}
	motor[rightMotor] = 0;
	motor[leftMotor] = 0;
	ret = SensorValue[leftEncoder];
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;
	//wait(1000);
	return ret;
}

int forwardUntilAway(int dist){
	int ret;
	while(SensorValue[sonar] > dist + 8){
		ret += goStraighter(2, -1);
	}
	
	return ret;
		
}



void navMaze(){
	
	int dir[10];
	
	bool end = false;
	int index = 0;
	
	while(!end){
		dir[index] = forwardUntilAway(34);
		wait(1000);
		leftTurn90();
		if(SensorValue[sonar] < 70){
			wait(1000);
			rightTurn180();
			dir[index] = dir[index] * -1;
			if(SensorValue[sonar] < 70){ 
				end = true;
			}
		}
		index++;
	}
	wait(1000);
	//leftTurn90();
	wait(500);
	//forwardUntilAway(5);
	rightTurn90();
	
	while(index >= 0){
		goStraighter(0, abs(dir[index]));
		if(sgn(dir[index]) == -1){
			leftTurn90();
		}else{
			rightTurn90();
		}
		index--;
	}
}






task main()
{

	while(SensorValue[bump] == 1){}
	/*
	turn(-1, 1);
	wait(1000);
	turn(1, 1);
	wait(1000);
	turn(-1, 2);
	wait(1000);
	turn(1, 2);
	*/
	//motor[leftMotor] = 40;
	//motor[rightMotor] = 40;
	/*
	wait(1000);
	turn(-1, 2);
	wait(1000);
	goStraight(100);
	//reverseForDistance(100);
	*/
	//forwardUntilAway(30);
	navMaze();
	//leftTurn90();
	//goStraighter(200);
}
