#pragma config(Sensor, dgtl1,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  bump,           sensorDigitalIn)
#pragma config(Sensor, dgtl8,  sonar,          sensorSONAR_cm)
#pragma config(Motor,  port2,           rightMotor,    tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port3,           leftMotor,     tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void wait(int val){
	wait1Msec(val);
}

void rampUp(int length, int targetSpeed, float fac, int dir){

	if(length == 0){
		length  = 30;
	}
	int time = length;
	int speed = 20;
	int interval = 5;

	while(speed < targetSpeed){
		motor[leftMotor] = speed * sgn(dir);
		motor[rightMotor] = speed * fac * sgn(dir);

		speed += interval;
		wait(time);
	}
	speed = targetSpeed;

}

void forwardForDistance(int dist){

	float a = 5.7;
	float k = .79;
	rampUp(0, 65, k, 1);
	while(SensorValue[rightEncoder] < dist*a){
		motor[leftMotor] = 65;
		motor[rightMotor] = 65 * k;
	}

	SensorValue[rightEncoder] = 0;

}

int reverseForDistance(int dist, int enc){

	wait(1000);

	SensorValue[rightEncoder] = 0;
	SensorValue[leftEncoder] = 0;

	float a = -5.8;
	float k = 1.1;
	rampUp(0, 25, k, -1);
	
	int num = dist * a;
	
	if(enc > 0){
		num = -enc;
	}
	
	while(SensorValue[leftEncoder] > num){
		motor[leftMotor] = -25;
		motor[rightMotor] = -25 * k;
	}
	
	motor[leftMotor] = 0;
	motor[rightMotor] = 0;
	
	int ret  = SensorValue[leftEncoder];
	SensorValue[rightEncoder] = 0;
	SensorValue[leftEncoder] = 0;
	
	return ret;
	
	//SensorValue[rightEncoder] = 0;

}

void turn(int dir, int num){
	//left turn  = -1, right turn = 1
	int speed = 50;
	for(int i  = 0; i < num; i++){

		if(dir < 0){
				
			SensorValue[rightEncoder] = 0;
			SensorValue[leftEncoder] = 0;


			int k = 180; //too big

			while(SensorValue[rightEncoder] < k){
				motor[leftMotor] = -speed;
				motor[rightMotor] = speed;
			}
			motor[leftMotor] = 0;
			motor[rightMotor] = 0;

		}else{
		
			SensorValue[rightEncoder] = 0;
			SensorValue[leftEncoder] = 0;


			int k = 180;

			while(SensorValue[rightEncoder] > -k){
				motor[leftMotor] = speed;
				motor[rightMotor] = -speed;
			}
			motor[leftMotor] = 0;
			motor[rightMotor] = 0;
		}

		
		wait(1000);
		SensorValue[rightEncoder] = 0;
		SensorValue[leftEncoder] = 0;

	}

}


void leftTurn90()
{
	

	SensorValue[rightEncoder] = 0;
	SensorValue[leftEncoder] = 0;

	int k = 179;

	while(SensorValue[rightEncoder] < k)
	{
		motor[rightMotor] = 40;
		motor[leftMotor] = -40;
	}
	motor[rightMotor] =0;
	motor[leftMotor] = 0;

	SensorValue[rightEncoder] = 0;
	wait(1000);
}

void leftTurn180()
{
	SensorValue[rightEncoder] = 0;
	SensorValue[leftEncoder] = 0;

	int k = 382;

	while(SensorValue[rightEncoder] < k)
	{
		motor[rightMotor] = 40;
		motor[leftMotor] = -40;
	}
	motor[rightMotor] =0;
	motor[leftMotor] = 0;

	SensorValue[rightEncoder] = 0;
	wait(1000);
}


int goStraighter(int dist, int encoder)
{
	float a = 4.6;
	int ret;
	
	//SensorValue[leftEncoder] = 0;
	//SensorValue[rightEncoder] = 0;
	int lEnc = SensorValue[leftEncoder];
	int rEnc = SensorValue[rightEncoder];
	
	int num = dist * a
	if(encoder > 0){
		num = encoder;
	}
 while(SensorValue[rightencoder] < num + rEnc && SensorValue[leftencoder] < num + lEnc)
	{
		while(SensorValue[rightencoder] == SensorValue[leftencoder] )
		{
			motor[rightMotor] = 40 * 0.79;
			motor[leftMotor] = 40;
			wait(10);
		}
		while(SensorValue[rightencoder] > SensorValue[leftencoder] )
		{
			motor[leftMotor] = 40;
			motor[rightMotor] = 30;
			wait(10);
		}
		while(SensorValue[rightencoder] < SensorValue[leftencoder] )
		{
			motor[leftMotor] = 30;
			motor[rightMotor] = 40;
			wait(10);
		}
	}
	motor[rightMotor] = 0;
	motor[leftMotor] = 0;
	ret = SensorValue[leftEncoder];
	//SensorValue[leftEncoder] = 0;
	//SensorValue[rightEncoder] = 0;
	//wait(1000);
	return ret;
}

int forwardUntilAway(int dist){
	int ret;
	while(SensorValue[sonar] > dist + 8 && SensorValue[sonar] <= 600){
		goStraighter(2, -1);
	}
	
	return SensorValue[leftEncoder];
		
}

int forwardHit(){
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;

	while(SensorValue[sonar] >= 4 && SensorValue[sonar] <= 600){
		motor[leftMotor] = 40;
		motor[rightMotor] = 40;
	}
	
	motor[leftMotor] = 0;
	motor[rightMotor] = 0;
	
	wait(500);
	
	return SensorValue[rightEncoder];
}



void navMaze(){
	
	int dir[10];
	
	int end = 0;
	int index = 0;
	
	while(end == 0){
		SensorValue[leftEncoder] = 0;
		SensorValue[rightEncoder] = 0;
		forwardUntilAway(29);
		dir[index] = SensorValue[leftEncoder];
		wait(1000);
		leftTurn90();
		//turn(-1,1);
		if(SensorValue[sonar] < 60){
			wait(1000);
			leftTurn180();
			//turn(-1,2);
			dir[index] = dir[index] * -1;
			if(SensorValue[sonar] < 70){ 
				end = index;
			}
		}
		index++;
	}
	index--;
	wait(1000);
	leftTurn90();
	wait(500);
	
	int f = forwardHit();
	wait(250);
	
	reverseForDistance(0, f);
	wait(500);
	leftTurn180();
	
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;
	
	while(index >= 0){
		SensorValue[leftEncoder] = 0;
		SensorValue[rightEncoder] = 0;
		if(index != end){
			if(sgn(dir[index]) == -1){
				leftTurn90();
			}else{
				turn(1,1);
			}
		}
		SensorValue[leftEncoder] = 0;
		SensorValue[rightEncoder] = 0;
		wait(1000);
		goStraighter(0, abs(dir[index]));
		wait(500);
		index--;
	}
}






task main()
{

	while(SensorValue[bump] == 1){}
	//int f = forwardHit();
	navMaze();
}
