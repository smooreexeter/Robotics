#pragma config(Sensor, in1,    rLine,          sensorLineFollower)
#pragma config(Sensor, in2,    lLine,          sensorLineFollower)
#pragma config(Sensor, dgtl1,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  start,          sensorDigitalIn)
#pragma config(Sensor, dgtl6,  top,            sensorDigitalIn)
#pragma config(Sensor, dgtl7,  sonar,          sensorSONAR_cm)
#pragma config(Sensor, dgtl9,  bottom,         sensorDigitalIn)
#pragma config(Motor,  port1,           lift,          tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           rightMotor,    tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port3,           leftMotor,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           claw,          tmotorServoStandard, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void wait(int t){
	wait1Msec(t);
}

//rampUp is used to slowly speed up the motors so the wheels don't spin
void rampUp(int length, int targetSpeed, float fac, int dir){
		//(length of time between speed changes, desired final speed,
		//a multiplier to keep the wheels straight, and direction (1 goes forward, -1 backwards))

	if(length == 0){
		//sets a default interval
		length  = 30; 
	}
	int time = length;
	int speed = 20;
	int interval = 5;

	while(speed < targetSpeed){
		motor[leftMotor] = speed * sgn(dir);
		motor[rightMotor] = speed * fac * sgn(dir);

		speed += interval;
		wait(time);
	}
	speed = targetSpeed;

}

int reverseForDistance(int dist, int enc){

	wait(1000);

	SensorValue[rightEncoder] = 0;
	SensorValue[leftEncoder] = 0;

	//constants so that dist is in cm
	float a = -5.8;
	float k = 1.1;
	rampUp(0, 25, k, -1);
	
	int num = dist * a;
	
	//if enc is set to a value (meaning that we want to specify distance in degrees), this overrides dist
	if(enc > 0){
		num = -enc;
	}
	
	while(SensorValue[leftEncoder] > num){
		motor[leftMotor] = -25;
		motor[rightMotor] = -25 * k;
	}
	
	motor[leftMotor] = 0;
	motor[rightMotor] = 0;
	
	int ret  = SensorValue[leftEncoder];
	SensorValue[rightEncoder] = 0;
	SensorValue[leftEncoder] = 0;
	
	return ret;
	

}

void turn(int dir, int num){
	//left turn: dir = -1, right turn: dir = 1; num specifies number of turns (1 = 90deg turn, 2 = 180deg, etc.)
	
	//we were having trouble getting these turns to be consistent, so we switched to using separate methods for left turns
	//and only used this when making right turns
	
	int speed = 50;
	
	//repeats depending on num
	for(int i  = 0; i < num; i++){

		//right turn
		if(dir < 0){
				
			SensorValue[rightEncoder] = 0;
			SensorValue[leftEncoder] = 0;


			int k = 180;

			while(SensorValue[rightEncoder] < k){
				motor[leftMotor] = -speed;
				motor[rightMotor] = speed;
			}
			motor[leftMotor] = 0;
			motor[rightMotor] = 0;
			
		//left turn
		}else{
		
			SensorValue[rightEncoder] = 0;
			SensorValue[leftEncoder] = 0;


			int k = 180;

			while(SensorValue[rightEncoder] > -k){
				motor[leftMotor] = speed;
				motor[rightMotor] = -speed;
			}
			motor[leftMotor] = 0;
			motor[rightMotor] = 0;
		}

		
		wait(1000);
		SensorValue[rightEncoder] = 0;
		SensorValue[leftEncoder] = 0;

	}

}


void leftTurn90()
{
	

	SensorValue[rightEncoder] = 0;
	SensorValue[leftEncoder] = 0;

	int k = 179;

	while(SensorValue[rightEncoder] < k)
	{
		motor[rightMotor] = 40;
		motor[leftMotor] = -40;
	}
	motor[rightMotor] =0;
	motor[leftMotor] = 0;

	SensorValue[rightEncoder] = 0;
	wait(1000);
}

void leftTurn180()
{
	SensorValue[rightEncoder] = 0;
	SensorValue[leftEncoder] = 0;

	int k = 382;

	while(SensorValue[rightEncoder] < k)
	{
		motor[rightMotor] = 40;
		motor[leftMotor] = -40;
	}
	motor[rightMotor] =0;
	motor[leftMotor] = 0;

	SensorValue[rightEncoder] = 0;
	wait(1000);
}


int goStraighter(int dist, int encoder){
	//this is our go straight function (so named because it went straigher than our "goStraight" function)

	//a is a constant to convert cm to encoder values
	float a = 4.6;
	int ret;
	
	//converting distance to an encoder value
	int num = dist * a
	
	//once again, if there is a value for encoder, we override the distance value
	if(encoder > 0){
		num = encoder;
	}
	
	//while both encoders are less than the final encoder value
	while(SensorValue[rightencoder] < num && SensorValue[leftencoder] < num){
		
		//goes straight if the encoders are equal
		while(SensorValue[rightencoder] == SensorValue[leftencoder] )
		{
			motor[rightMotor] = 80 * 0.79;
			motor[leftMotor] = 80;
			wait(10);
		}
		//turns slight right if it is drifting to the left
		while(SensorValue[rightencoder] > SensorValue[leftencoder] )
		{
			motor[leftMotor] = 80;
			motor[rightMotor] = 60;
			wait(10);
		}
		//turns slight left if it is drifting to the right
		while(SensorValue[rightencoder] < SensorValue[leftencoder] )
		{
			motor[leftMotor] = 60;
			motor[rightMotor] = 80;
			wait(10);
		}
	}
	motor[rightMotor] = 0;
	motor[leftMotor] = 0;
	ret = SensorValue[leftEncoder];
	
	//In case we want to return the actual distance covered
	return ret;
}

int forwardUntilAway(int dist){
	//dist is in cm

	int ret;
	
	//while the sonar is reading a value slightly larger than the target (to account for inertia) and when it 
	//isn't reading a very large value (we found this tended to happen when the sensor was pushed against a wall
	while(SensorValue[sonar] > dist + 8 && SensorValue[sonar] <= 600){
		goStraighter(2, -1);
	}
	
	//returns the distance the robot traveled 
	return SensorValue[leftEncoder];
		
}

void liftClaw(){
	while(SensorValue[top] == 1){
		motor[lift] = 80;
	}
	motor[lift] = 0;
}

void lowerClaw(){
	while(SensorValue[bottom] == 1){
		motor[lift] = -80;
	}
	motor[lift] = 0;
}

task main()
{
	
	motor[claw] = -127;
	
	lowerClaw();
	
	wait(500);
	
	liftClaw();
	
	motor[claw] = 127;
	
	wait(500);
	
	motor[claw] = -127;

	while(SensorValue[start] == 1){}

	motor[claw] = -127;
	
	liftClaw();
	
	motor[lift] = 0;
	
	wait(500);
	
	forwardUntilAway(10);
	
	lowerClaw();
	
	motor[claw] = 127;
	
	liftClaw();
	
	while(SensorValue[lLine] < 1000 && SensorValue[rLine] < 1000){
		goStraighter(2, -1);
		wait(10);
	}
	
	wait(500);
	
	motor[claw] = -127;

}
