#pragma config(Sensor, dgtl1,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  bump,           sensorDigitalIn)
#pragma config(Motor,  port2,           rightMotor,    tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port3,           leftMotor,     tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


void wait(int val){
	wait1Msec(val);
}

void rampUp(int length, int targetSpeed, float fac, int dir){
	
	if(length == 0){
		length  = 30;
	}
	int time = length;
	int speed = 20;
	int interval = 5;
	
	while(speed < targetSpeed){
		motor[leftMotor] = speed * sgn(dir);
		motor[rightMotor] = speed * fac * sgn(dir);

		speed += interval;
		wait(time);
	}
	speed = targetSpeed;

}

void forwardForDistance(int dist){
	
	float a = 5.7;
	float k = .79;
	rampUp(0, 65, k, 1);
	while(SensorValue[rightEncoder] < dist*a){
		motor[leftMotor] = 65;
		motor[rightMotor] = 65 * k;
	}
	
	SensorValue[rightEncoder] = 0;

}

void reverseForDistance(int dist){
	
	float a = -5.8;
	float k = 1.1;
	rampUp(0, 65, k, -1);
	while(SensorValue[rightEncoder] > dist*a){
		motor[leftMotor] = -65;
		motor[rightMotor] = -65 * k;
	}
	
	SensorValue[rightEncoder] = 0;

}

void turn(int dir, int num){
	//left turn  = -1, right turn = 1
	for(int i  = 0; i < num; i++){
		
		if(dir < 0){
			
			int k = 250; //too big

			while(SensorValue[rightEncoder] < k){
				motor[leftMotor] = -80;
				motor[rightMotor] = 80;
			}
			motor[leftMotor] = 0;
			motor[rightMotor] = 0;
		
		}else{
		
			int k = 250;

			while(SensorValue[rightEncoder] > -k){
				motor[leftMotor] = 80;
				motor[rightMotor] = -80;
			}
			motor[leftMotor] = 0;
			motor[rightMotor] = 0;
		}
		
		SensorValue[rightEncoder] = 0;
		wait(1000);
	
	}
	
}

void goStraight(int dist){
	
	float a = 5.7;
	float k = 0.79;
	//rampUp(0, 65, k, 1);
	int R = 40;
	//float g = 1;
	int RE = 0;
	int LE = 0;
	
	//SensorValue[leftEncoder] = 10;
	//SensorValue[rightEncoder] = 10;
	
	while(SensorValue[rightEncoder] < dist * a  && SensorValue[leftEncoder] < dist * a){
		
		motor[leftMotor] = 40;
		motor[rightMotor] = R;
		LE = SensorValue[leftEncoder];
		RE = SensorValue[rightEncoder];
		//if(RE > 1){
	  	R = R * (LE + 1) / (RE + 1);
		//} else{
		//	R = 40;
		//}
		wait(500);
		
	}
	
	//SensorValue[leftEncoder] = 0;
	//SensorValue[rightEncoder] = 0;
	motor[leftMotor] = 0;
	motor[rightMotor] = 0;

}

void goStraighter(int dist)
{
float a = 4.6;
 while(SensorValue[rightencoder] < dist * a && SensorValue[leftencoder] < dist * a)
{
	while(SensorValue[rightencoder] == SensorValue[leftencoder] )
	{
		motor[rightMotor] = 40;
		motor[leftMotor] = 40;
		wait(250);
	}
	while(SensorValue[rightencoder] > SensorValue[leftencoder] )
	{
		motor[leftMotor] = 40;
		motor[rightMotor] = 30;
		wait(250);
	}
	while(SensorValue[rightencoder] < SensorValue[leftencoder] )
	{
		motor[leftMotor] = 30;
		motor[rightMotor] = 40;
		wait(250);
	}
}
SensorValue[leftEncoder] = 0;
SensorValue[rightEncoder] = 0;
wait(1000);
}

task main()
{

	while(SensorValue[bump] == 1){}
	/*
	turn(-1, 1);
	wait(1000);
	turn(1, 1);
	wait(1000);
	turn(-1, 2);
	wait(1000);
	turn(1, 2);
	*/
	//goStraighter(200);
	turn(1,2);
	//goStraighter(200);
	/*
	wait(1000);
	turn(-1, 2);
	wait(1000);
	goStraight(100);
	//reverseForDistance(100);
	*/
}
