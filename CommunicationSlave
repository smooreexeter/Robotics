#pragma config(Sensor, in1,    rrLine,         sensorLineFollower)
#pragma config(Sensor, in2,    rlLine,         sensorLineFollower)
#pragma config(Sensor, in3,    lLine,          sensorLineFollower)
#pragma config(Sensor, dgtl1,  din,            sensorDigitalIn)
#pragma config(Sensor, dgtl2,  bump,           sensorDigitalIn)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  rightEncoder,   sensorQuadEncoder)
#pragma config(Motor,  port2,           rightMotor,    tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port3,           leftMotor,     tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

struct stackElem{
	int val;
} stackElem;

struct Stack{
	stackElem elements[16];
	int size;
}Stack;

void wait(int var){
	wait1Msec(var);
}
















/*
bool hitLine = false;
int lineThresh = 3000;
int reverseForDistance(int dist, int enc){

	wait(1000);

	SensorValue[rightEncoder] = 0;
	SensorValue[leftEncoder] = 0;

	//constants so that dist is in cm
	float a = -5.8;
	float k = 1.1;
	
	int num = dist * a;
	
	//if enc is set to a value (meaning that we want to specify distance in degrees), this overrides dist
	if(enc > 0){
		num = -enc;
	}
	
	motor[leftMotor] = -25;
	motor[rightMotor] = -25
	
	while(SensorValue[leftEncoder] > num){
		motor[leftMotor] = -25;
		motor[rightMotor] = -40; //* k;
	}
	
	motor[leftMotor] = 0;
	motor[rightMotor] = 0;
	
	int ret  = SensorValue[leftEncoder];
	
	SensorValue[rightEncoder] = 0;
	SensorValue[leftEncoder] = 0;
	
	return ret;
	

}


void leftTurn90()
{
	

	SensorValue[rightEncoder] = 0;
	SensorValue[leftEncoder] = 0;

	int k = 260;

	while(SensorValue[rightEncoder] < k)
	{
		if(SensorValue[rightEncoder] == -SensorValue[leftEncoder]){
			motor[rightMotor] = 50;
			motor[leftMotor] = -50;
		}else if(SensorValue[rightEncoder] > -SensorValue[leftEncoder]){
			motor[rightMotor] = 30;
			motor[leftMotor] = -50;
		}else{
			motor[rightMotor] = 50;
			motor[leftMotor] = -30;
		}
	}
	motor[rightMotor] =0;
	motor[leftMotor] = 0;

	SensorValue[rightEncoder] = 0;
	SensorValue[leftEncoder] = 0;
	wait(1000);
}

void leftTurn180()
{
		SensorValue[rightEncoder] = 0;
	SensorValue[leftEncoder] = 0;

	int k = 550;

	while(SensorValue[rightEncoder] < k)
	{
		if(SensorValue[rightEncoder] == -SensorValue[leftEncoder]){
			motor[rightMotor] = 50;
			motor[leftMotor] = -50;
		}else if(SensorValue[rightEncoder] > -SensorValue[leftEncoder]){
			motor[rightMotor] = 30;
			motor[leftMotor] = -50;
		}else{
			motor[rightMotor] = 50;
			motor[leftMotor] = -30;
		}
	}
	motor[rightMotor] =0;
	motor[leftMotor] = 0;

	SensorValue[rightEncoder] = 0;
	SensorValue[leftEncoder] = 0;
	wait(1000);
}


int goStraighter(int dist, int encoder){
	//this is our go straight function (so named because it went straigher than our "goStraight" function)

	//a is a constant to convert cm to encoder values
	
	int motorSpeed = 80;

	float a = 4.6;
	int ret;
	
	int lEnc = SensorValue[leftEncoder];  
	int rEnc = SensorValue[rightEncoder];  

	
	//converting distance to an encoder value
	int num = dist * a
	
	//once again, if there is a value for encoder, we override the distance value
	if(encoder > 0){
		num = encoder;
	}
	
	//while both encoders are less than the final encoder value
	while(SensorValue[rightencoder] < num + rEnc && SensorValue[leftencoder] < num + lEnc){
		
		//goes straight if the encoders are equal
		while(SensorValue[rightencoder] == SensorValue[leftencoder] )
		{
			motor[rightMotor] = motorSpeed;
			motor[leftMotor] = motorSpeed;
			wait(10);
		}
		//turns slight right if it is drifting to the left
		while(SensorValue[rightencoder] > SensorValue[leftencoder] )
		{
			motor[leftMotor] = motorSpeed;
			motor[rightMotor] = motorSpeed - 20;
			wait(10);
		}
		//turns slight left if it is drifting to the right
		while(SensorValue[rightencoder] < SensorValue[leftencoder] )
		{
			motor[leftMotor] = motorSpeed - 20;
			motor[rightMotor] = motorSpeed;
			wait(10);
		}
	}
	motor[rightMotor] = 0;
	motor[leftMotor] = 0;
	ret = SensorValue[leftEncoder];
	
	//In case we want to return the actual distance covered
	return ret;
}



int forwardHit(){
	//used when hitting the final wall

	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;

	//we found that at 4cm away the robot would continue to roll forward and hit the wall
	while(SensorValue[sonar] >= 4 && SensorValue[sonar] <= 600){
		motor[leftMotor] = 40;
		motor[rightMotor] = 40;
	}
	
	motor[leftMotor] = 0;
	motor[rightMotor] = 0;
	
	wait(500);
	
	//returns the distance to the wall so that we can back up the same amount
	return SensorValue[rightEncoder];
}

void navToLine(){
	
	int thresh = 2200;
	
	while(SensorValue[lLine] < thresh && SensorValue[rlLine] < thresh){
		goStraighter(2,1);
	}
		
	if(SensorValue[lLine] < thresh && SensorValue[rlLine] > thresh){
		while(SensorValue[lLine] < thresh){
			motor[leftMotor] = 40;
		}
		motor[leftMotor] = 0;
	}else if(SensorValue[rlLine] < thresh && SensorValue[lLine] > thresh){
		while(SensorValue[rlLine] < thresh){
			motor[rightMotor] = 40;
		}
		motor[rightMotor] = 0;
	}
		
	int pos = -1;
	
	while(SensorValue[lLine] > thresh){
		goStraighter(1,1);
	}
}




void navMaze(){
	//the one function which runs the maze
	
	//sets up our array to navigate back
	int dir[10];
	
	//variables used in getting back
	int end = 0;
	int index = 0;
	
	//end is set to a nonzero value once the robot finds the end
	while(end == 0){
		//starts by zeroing encoders
		SensorValue[leftEncoder] = 0;
		SensorValue[rightEncoder] = 0;
		
		//29 cm was just enough to get our robot around corners and not hit the wall it sensed
		forwardUntilAway(29);
		
		//sets the array value at the index to be the distance traveled
		dir[index] = SensorValue[leftEncoder];
		wait(1000);
		leftTurn90();
		
		//if there is another wall detected
		if(SensorValue[sonar] < 60){
			wait(1000);
			leftTurn180();
			
			//if it needs to do a right turn, we set the array value to be negative; this is then used to 
			//turn when navigating out
			dir[index] = dir[index] * -1;
			
			//if there is still a wall, we are at the end and index is 
			if(SensorValue[sonar] < 70){ 
				end = index;
			}
		}
		
		//advances the index for the next iteration
		index++;
	}
	//since we want to access the most recent array value and index was just increased, we decrease it again
	index--;
	wait(1000);
	
	//reorient the robot to face the final wall
	leftTurn90();
	wait(500);
	
	//forwardhit returns encoder values to the wall
	int f = forwardHit();
	wait(250);
	
	//back up the same distance forwardhit traveled
	reverseForDistance(0, f);
	wait(500);
	leftTurn180();
	
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;
	
	dir[0] = dir[0] - 300;
	
	//when index is less than 0, the robot has completed all the steps it made going in
	while(index >= 0){
		
		//zeroing encoders
		SensorValue[leftEncoder] = 0;
		SensorValue[rightEncoder] = 0;
		
		//when we finished the maze, end was set to index. At this point we are facing away from the last wall and
		//don't want to turn again
		if(index != end){
		
			//if the distance is negative, it was a right turn, so we need to turn left when going in reverse
			if(sgn(dir[index]) == -1){
				leftTurn90();
				
			//otherwise turn right
			}else{
				leftTurn180();
				leftTurn90();
			}
		}
		
		SensorValue[leftEncoder] = 0;
		SensorValue[rightEncoder] = 0;
		wait(1000);
		
		//go forward for the absolute value of the distance so that it isn't confused by the negative numbers
		
		goStraighter(0, abs(dir[index]));
		wait(500);
		
		//decrease the index to complete the next step in the maze
		index--;
	}
	
	navToLine();

	
}

*/
















int numTurns = 10;
int testVal = 0;
Stack st[10];
int dir[10];
bool neg[10];
int stat = 0;


bool push(Stack stack, int val){
	if(stack.size == 16){
		return false;
	}
	
	stack.elements[stack.size++].val = val;
	return true;
}

int pop(Stack stack){
	if(stack.size == 0){
		return -1;
	}
	
	return stack.elements[--stack.size].val;
}

void  createBinary(Stack st, int val){
	
	int pushVal;
	
	while(val > 0){
		pushVal = val%2;
		push(st, pushVal);
		val = (val - pushVal) / 2;
	}
	
}

/*
void stackOut(Stack st){
	
		while(st.size > 0){
		if(pop(st) == 1){
			SensorValue[dOut] = 0;
			wait(500);
			SensorValue[dOut] = 1;
		}else{
			SensorValue[dOut] = 0;
			wait(250);
			SensorValue[dOut] = 1;
			wait(250);
		}
		wait(500);	
	}
}


void com(){

	
	for(int i = 0; i < numTurns; i++){
		createBinary(st[i], abs(dir[i]));
	}
	
	SensorValue[dOut] = 1;
	wait(1000);
	SensorValue[dOut] = 0;
	wait(500);
	
	int temp;
	
	for(int i = 0; i < numTurns; i++){
		for(int j = 0; j < st.size; j++){
			temp = pop(st[i]);
			if(temp == 0){
				wait(10);
			}else{
				SensorValue[dOut] = 1;
				wait(10);
				SensorValue[dOut] = 0;
			}
			wait(5);
		}
		if(sgn(dir[i]) == 1){
			SensorValue[dOut] = 1;
			wait(50);
			SensorValue[dOut] = 0;
			wait(250);
		}else{
			SensorValue[dOut] = 1;
			wait(10);
			SensorValue[dOut] = 0;
			wait(290);
		}
	}
}
*/
/*
int binaryToInt(int i){
	int ret = 0;
	bool popVal;
	int tempPowVal = 0;
	
	for(int j = 0; j < 16; j++){
		popVal = bin[i][j];
		if(popVal == true){
			tempPowVal = pow(2, j);
			ret += tempPowVal;
		}
		return ret;
	}
	
	return 0;
	
}
*/

int binaryToInt(Stack tempStack){
	int ret = 0;
	int power = tempStack.size;
	int popVal;
	int tempPowVal = 0;
	stat = 200 + tempStack.size;
	while(tempStack.size > 0){
		popVal = pop(tempStack);
		if(popVal == 1){
			tempPowVal = pow(2, power);
			ret += tempPowVal;
		}
		power--;
		
		stat = 10000 + ret;
		return ret;
	}
	
	return 1;
	
}

void recCom(){
	bool stillCom = true;
	bool sameNum = true;
	int time = 0;
	int tempOutput;
	
	for(int i = 0; i < 10; i++){
		if(stillCom){
			while(sameNum){
				while(SensorValue[din] == 1){}
				clearTimer(T1);
				while(SensorValue[din] == 0){}
				time = time1(T1);
				if(time < 501 && time > 499){
				}else if(time < 21 && time > 19){
					push(st[i], 0);
				}else if(time < 11 && time > 9){
					push(st[i], 1);
				}else if(time < 41 && time > 39){
					neg[i] = false;
				}else if(time < 31 && time > 29){
					neg[i] = true;
				}else if(time < 51 && time > 49){
					sameNum = false;
				}else if(time < 501 && time > 499){
					testVal = 4440 + i;
					stillCom = false;
				}
			}
			stat = 100 + i;
			tempOutput = binaryToInt(st[i]);
			//stat = 20000 + tempOutput;
			dir[i] = tempOutput;
			if(neg[i] == true){
				dir[i] = -1 * dir[i];
			}
			sameNum = true;
			testVal = 7788;
		}
	}
	
	testVal = 4389;
	
}
	
		


task main(){
	/*
	for(int i = 0; i < 10; i++){
		for(int j = 0; j < 16; j++){
			bin[i][j] = false;
		}
	}
	*/
	recCom();
	//testVal = dir[0];

}
