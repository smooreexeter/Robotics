#pragma config(Sensor, in1,    rrLine,         sensorLineFollower)
#pragma config(Sensor, in2,    rlLine,         sensorLineFollower)
#pragma config(Sensor, in3,    lLine,          sensorLineFollower)
#pragma config(Sensor, dgtl1,  din,            sensorDigitalIn)
#pragma config(Sensor, dgtl2,  bump,           sensorDigitalIn)
#pragma config(Sensor, dgtl3,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  leftEncoder,    sensorQuadEncoder)
#pragma config(Motor,  port2,           rightMotor,    tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port3,           leftMotor,     tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

struct stackElem{
	int val;
} stackElem;

struct Stack{
	stackElem elements[16];
	int size;
}Stack;

void wait(int var){
	wait1Msec(var);
}











int gaveStop = 0;
int numTurns = 10;
int testVal = 0;
Stack st[10];
int dir[10];
bool neg[10];
int stat = 0;
int sizeOfDir = 10;
int index = 0;






int reverseForDistance(int dist, int enc){

	wait(1000);

	SensorValue[rightEncoder] = 0;
	SensorValue[leftEncoder] = 0;

	//constants so that dist is in cm
	float a = -5.8;
	float k = 1.1;
	
	int num = dist * a;
	
	//if enc is set to a value (meaning that we want to specify distance in degrees), this overrides dist
	if(enc > 0){
		num = -enc;
	}
	
	motor[leftMotor] = -40;
	motor[rightMotor] = -40
	
	while(SensorValue[leftEncoder] > num){
		motor[leftMotor] = -40;
		motor[rightMotor] = -40; //* k;
	}
	
	motor[leftMotor] = 0;
	motor[rightMotor] = 0;
	
	int ret  = SensorValue[leftEncoder];
	
	SensorValue[rightEncoder] = 0;
	SensorValue[leftEncoder] = 0;
	
	return ret;
	

}


void leftTurn90()
{
	

	SensorValue[rightEncoder] = 0;
	SensorValue[leftEncoder] = 0;

	int k = 280;

	while(SensorValue[rightEncoder] < k)
	{
		if(SensorValue[rightEncoder] == -SensorValue[leftEncoder]){
			motor[rightMotor] = 50;
			motor[leftMotor] = -50;
		}else if(SensorValue[rightEncoder] > -SensorValue[leftEncoder]){
			motor[rightMotor] = 30;
			motor[leftMotor] = -50;
		}else{
			motor[rightMotor] = 50;
			motor[leftMotor] = -30;
		}
	}
	motor[rightMotor] =0;
	motor[leftMotor] = 0;

	SensorValue[rightEncoder] = 0;
	SensorValue[leftEncoder] = 0;
	wait(1000);
}

void leftTurn180()
{
		SensorValue[rightEncoder] = 0;
	SensorValue[leftEncoder] = 0;

	int k = 580;

	while(SensorValue[rightEncoder] < k)
	{
		if(SensorValue[rightEncoder] == -SensorValue[leftEncoder]){
			motor[rightMotor] = 50;
			motor[leftMotor] = -50;
		}else if(SensorValue[rightEncoder] > -SensorValue[leftEncoder]){
			motor[rightMotor] = 30;
			motor[leftMotor] = -50;
		}else{
			motor[rightMotor] = 50;
			motor[leftMotor] = -30;
		}
	}
	motor[rightMotor] =0;
	motor[leftMotor] = 0;

	SensorValue[rightEncoder] = 0;
	SensorValue[leftEncoder] = 0;
	wait(1000);
}


int goStraighter(int dist, int encoder){
	//this is our go straight function (so named because it went straigher than our "goStraight" function)

	//a is a constant to convert cm to encoder values
	
	int motorSpeed = 80;

	float a = 4.6;
	int ret;
	
	int lEnc = SensorValue[leftEncoder];  
	int rEnc = SensorValue[rightEncoder];  

	
	//converting distance to an encoder value
	int num = dist * a
	
	//once again, if there is a value for encoder, we override the distance value
	if(encoder > 0){
		num = encoder;
	}
	
	//while both encoders are less than the final encoder value
	while(SensorValue[rightencoder] < num + rEnc && SensorValue[leftencoder] < num + lEnc){
		
		//goes straight if the encoders are equal
		while(SensorValue[rightencoder] == SensorValue[leftencoder] )
		{
			motor[rightMotor] = motorSpeed;
			motor[leftMotor] = motorSpeed;
			wait(10);
		}
		//turns slight right if it is drifting to the left
		while(SensorValue[rightencoder] > SensorValue[leftencoder] )
		{
			motor[leftMotor] = motorSpeed;
			motor[rightMotor] = motorSpeed - 20;
			wait(10);
		}
		//turns slight left if it is drifting to the right
		while(SensorValue[rightencoder] < SensorValue[leftencoder] )
		{
			motor[leftMotor] = motorSpeed - 20;
			motor[rightMotor] = motorSpeed;
			wait(10);
		}
	}
	motor[rightMotor] = 0;
	motor[leftMotor] = 0;
	ret = SensorValue[leftEncoder];
	
	//In case we want to return the actual distance covered
	return ret;
}

int forwardUntilAway(int i){
	//dist is in cm

	goStraighter(1, dir[i]);
	
	//returns the distance the robot traveled 
	return SensorValue[leftEncoder];
		
}



void navMaze(){
	
	for(int i = 0; i < 10; i++){
		if(dir[i] == 0){
			sizeOfDir = i;
			i = 10;
		}
	}
	
	
	//when index is less than 0, the robot has completed all the steps it made going in
	while(index < sizeOfDir && dir[index] != 0){
		
		//zeroing encoders
		SensorValue[leftEncoder] = 0;
		SensorValue[rightEncoder] = 0;
		
		testVal = 2233;
		
		//when we finished the maze, end was set to index. At this point we are facing away from the last wall and
		//don't want to turn again
		if(index > 0 && abs(dir[index]) > 0){
		
			//if the distance is negative, it was a right turn, so we need to turn right when going in reverse
			if(sgn(dir[index - 1]) == -1){
				leftTurn90();
				leftTurn180();
				
			//otherwise turn left
			}else{
				leftTurn90();
				testVal = 555;
			}
		}
		
		testVal = 6000;
		SensorValue[leftEncoder] = 0;
		SensorValue[rightEncoder] = 0;
		wait(1000);
		
		//go forward for the absolute value of the distance so that it isn't confused by the negative numbers
		testVal = 10000 + dir[index];
		goStraighter(0, abs(dir[index]));
		wait(500);
		
		//decrease the index to complete the next step in the maze
		index++;
		testVal = 9999;
	}
	
	index--;
	
	leftTurn180();
	
	while(index >= 0){
		
		//zeroing encoders
		SensorValue[leftEncoder] = 0;
		SensorValue[rightEncoder] = 0;
		
		//when we finished the maze, end was set to index. At this point we are facing away from the last wall and
		//don't want to turn again
		if(index != sizeOfDir - 1){
		
			//if the distance is negative, it was a right turn, so we need to turn left when going in reverse
			if(sgn(dir[index]) == -1){
				leftTurn90();
				
			//otherwise turn right
			}else{
				leftTurn90();
				leftTurn180();
			}
		}
		
		SensorValue[leftEncoder] = 0;
		SensorValue[rightEncoder] = 0;
		wait(1000);
		
		//go forward for the absolute value of the distance so that it isn't confused by the negative numbers
		
		goStraighter(0, abs(dir[index]));
		wait(500);
		
		//decrease the index to complete the next step in the maze
		index--;
	}
	
}

















bool push(Stack stack, int val){
	if(stack.size == 16){
		return false;
	}
	
	stack.elements[stack.size++].val = val;
	return true;
}

int pop(Stack stack){
	if(stack.size == 0){
		return -1;
	}
	
	return stack.elements[--stack.size].val;
}

void  createBinary(Stack st, int val){
	
	int pushVal;
	
	while(val > 0){
		pushVal = val%2;
		push(st, pushVal);
		val = (val - pushVal) / 2;
	}
	
}



int binaryToInt(Stack tempStack){
	int ret = 0;
	int power = tempStack.size;
	int originalPower = tempStack.size;
	int popVal;
	int tempPowVal = 0;
	stat = 200 + tempStack.size;
	while(tempStack.size > 0){
		popVal = pop(tempStack);
		if(popVal == 1){
			tempPowVal = pow(2, originalPower - power);
			ret += tempPowVal;
		}
		power--;
		
		
	stat = 200 + tempStack.size;
	}
	
	stat = 10000 + ret;
	return ret;
	
}

void recCom(){
	bool stillCom = true;
	bool sameNum = true;
	int time = 0;
	int timeTemp = 0;
	int tempOutput;
	
	for(int i = 0; i < 10; i++){
		if(stillCom){
			while(sameNum){
				while(SensorValue[din] == 1){}
				clearTimer(T1);
				while(SensorValue[din] == 0){}
				time = time1(T1);
				if(time < 501 && time > 499){
				}else if(time < 21 && time > 19){
					push(st[i], 0);
				}else if(time < 11 && time > 9){
					push(st[i], 1);
				}else if(time < 41 && time > 39){
					neg[i] = false;
				}else if(time < 31 && time > 29){
					neg[i] = true;
				}else if(time < 51 && time > 49){
					sameNum = false;
					while(SensorValue[din] == 1){}
					clearTimer(T2);
					while(SensorValue[din] == 0){}
					timeTemp = time1(T2);
					if(timeTemp < 61 && timeTemp > 59){
					}else if(timeTemp < 501 && timeTemp > 499){
						testVal = 4440 + i;
						stillCom = false;
						gaveStop = i;
					}
				}
				
			}
			stat = 100 + i;
			tempOutput = binaryToInt(st[i]);
			//stat = 20000 + tempOutput;
			dir[i] = tempOutput;
			if(neg[i] == true){
				dir[i] = -1 * dir[i];
			}
			sameNum = true;
			testVal = 7788;
		}
	}
	
	testVal = 4389;
	
}
	
		


task main(){
	
	for(int i = 0; i < 10; i++){
		dir[i] = -1;
	}
	
	recCom();
	
	while(SensorValue[bump] == 1){}
	
	navMaze();

}
